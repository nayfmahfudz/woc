import { isRef, isReactive, watch, ref, computed, reactive, unref, shallowReactive } from 'vue';

class LinkedListNode {
    constructor(value) {
        this.next = null;
        this.prev = null;
        this.value = value;
    }
}
class LinkedList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.count = 0;
    }
    get first() {
        return this.head;
    }
    get last() {
        return this.tail;
    }
    addFirst(value) {
        const node = new LinkedListNode(value);
        if (this.count === 0) {
            this.head = node;
            this.tail = node;
        }
        else {
            node.next = this.head;
            this.head.prev = node;
            this.head = node;
        }
        this.count++;
        return node;
    }
    addLast(value) {
        const node = new LinkedListNode(value);
        if (this.count === 0) {
            this.head = node;
            this.tail = node;
        }
        else {
            node.prev = this.tail;
            this.tail.next = node;
            this.tail = node;
        }
        this.count++;
        return node;
    }
    remove(node) {
        if (this.count === 0) {
            return;
        }
        if (node === this.head) {
            this.removeFirst();
        }
        else if (node === this.tail) {
            this.removeLast();
        }
        else {
            node.prev.next = node.next;
            node.next.prev = node.prev;
            node.next = null;
            node.prev = null;
            this.count--;
        }
    }
    removeFirst() {
        if (this.count === 0) {
            return;
        }
        if (this.count === 1) {
            this.head = null;
            this.tail = null;
            this.count--;
        }
        else {
            this.head = this.head.next;
            this.head.prev.next = null;
            this.head.prev = null;
            this.count--;
        }
    }
    removeLast() {
        if (this.count === 0) {
            return;
        }
        if (this.count === 1) {
            this.head = null;
            this.tail = null;
            this.count--;
        }
        else {
            this.tail = this.tail.prev;
            this.tail.next.prev = null;
            this.tail.next = null;
            this.count--;
        }
    }
    valuesForwards() {
        let node = this.head;
        return {
            *[Symbol.iterator]() {
                for (; node !== null; node = node.next) {
                    yield node.value;
                }
            }
        };
    }
    valuesBackwards() {
        let node = this.tail;
        return {
            *[Symbol.iterator]() {
                for (; node !== null; node = node.prev) {
                    yield node.value;
                }
            }
        };
    }
}

function* deepIterator(obj, predicate = () => false) {
    const stack = new LinkedList();
    stack.addLast([obj, null, '', []]);
    while (stack.count > 0) {
        const [current, parent, parentKey, path] = stack.last.value;
        stack.removeLast();
        let pushedItemsOnStack = false;
        if (typeof current === 'object' &&
            current !== null &&
            !isRef(current) &&
            !predicate(current)) {
            const entries = Object.entries(current);
            pushedItemsOnStack = entries.length > 0;
            for (let i = entries.length - 1; i >= 0; i--) {
                const [key, value] = entries[i];
                stack.addLast([value, current, key, [...path, key]]);
            }
        }
        if (typeof parent === 'object' && parent !== null) {
            yield [parentKey, parent[parentKey], parent, path, !pushedItemsOnStack];
        }
    }
}

const isDefined = (x) => x !== null && typeof x !== 'undefined';
const isObject = (x) => typeof x === 'object' && x !== null && !Array.isArray(x);
const isArray = (x) => Array.isArray(x);
const isField = (x) => isObject(x) ? '$value' in x : false;
const isTransformedField = (x) => isObject(x)
    ? '$uid' in x && '$value' in x && '$errors' in x && '$validating' in x
    : false;

function cleanupForm(form, deletedData) {
    if (isTransformedField(deletedData)) {
        form.onDelete(deletedData.$uid);
        return;
    }
    for (const [, value] of deepIterator(deletedData, isTransformedField)) {
        if (isTransformedField(value)) {
            form.onDelete(value.$uid);
        }
    }
}

function set(obj, keys, value) {
    if (keys.length === 0) {
        return;
    }
    let o = obj;
    for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        const nextKey = keys[i + 1];
        const value = o[key];
        if (value === undefined) {
            if (Number.isNaN(+nextKey)) {
                o[key] = {};
            }
            else {
                o[key] = [];
            }
        }
        o = o[key];
    }
    o[keys[keys.length - 1]] = value;
}

function deepCopy(toClone) {
    if (typeof toClone !== 'object') {
        return toClone;
    }
    const copy = isArray(toClone) ? [] : {};
    for (const [, value, , path, isLeaf] of deepIterator(toClone)) {
        if (isLeaf) {
            set(copy, path, value);
        }
    }
    return copy;
}

function getResultFormData(transformedFormData) {
    const result = {};
    for (const [, value, , path, isLeaf] of deepIterator(transformedFormData, isTransformedField)) {
        if (isTransformedField(value)) {
            if (isReactive(value.$value)) {
                set(result, path, deepCopy(value.$value));
            }
            else {
                set(result, path, value.$value);
            }
        }
        else if (isLeaf) {
            if (isReactive(value)) {
                set(result, path, deepCopy(value));
            }
            else {
                set(result, path, value);
            }
        }
    }
    return result;
}

function resetFields(formData, transformedFormData) {
    Object.entries(formData).forEach(([key, value]) => {
        const transformedValue = transformedFormData[key];
        if (isTransformedField(transformedValue)) {
            if (isArray(transformedValue.$value)) {
                transformedValue.$value = deepCopy(value);
            }
            else if (isObject(transformedValue.$value)) {
                const copy = deepCopy(value);
                Object.assign(transformedValue.$value, copy);
            }
            else {
                transformedValue.$value = value;
            }
            return;
        }
        if (typeof value === 'object') {
            resetFields(value, transformedFormData[key]);
        }
    });
}

let uid = 1;
function useUid() {
    return uid++;
}

function registerField(form, name, field) {
    var _a;
    const uid = useUid();
    const formField = form.registerField(uid, name, field.$value, (_a = field.$rules) !== null && _a !== void 0 ? _a : []);
    watch(formField.modelValue, () => {
        if (formField.touched) {
            form.validate(uid);
        }
    }, { deep: true });
    return {
        $uid: uid,
        $value: formField.modelValue,
        $errors: formField.errors,
        $hasError: formField.hasError,
        $validating: formField.validating,
        async $onBlur() {
            if (!formField.touched) {
                formField.touched = true;
                await form.validate(uid);
            }
        }
    };
}
function transformFormData(form, data) {
    for (const [key, value, parent] of deepIterator(data)) {
        if (isField(value)) {
            const transformedField = registerField(form, key, value);
            parent[key] = transformedField;
        }
    }
}

const tryGet = (map) => ({ success, failure }) => (key) => {
    const value = map.get(key);
    if (value) {
        success(value);
    }
    else {
        failure === null || failure === void 0 ? void 0 : failure();
    }
};

const trySet = (map) => ({ success, failure }) => (key, value) => {
    const _value = map.get(key);
    if (_value) {
        failure === null || failure === void 0 ? void 0 : failure(_value);
    }
    else {
        map.set(key, value);
        success === null || success === void 0 ? void 0 : success(value);
    }
};

function path(path, o) {
    let value = o[path[0]];
    for (let i = 0; i < path.length; i++) {
        const key = path[i];
        if (value === null || value === undefined) {
            return undefined;
        }
        if (i > 0) {
            value = value[key];
        }
    }
    return value;
}

class PromiseCancel {
    constructor() {
        this.assign();
    }
    cancelResolve(value) {
        this.resolve(value);
        this.assign();
    }
    cancelReject(reason) {
        this.reject(reason);
        this.assign();
    }
    race(...promises) {
        return Promise.race([this.promise, ...promises]);
    }
    assign() {
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
}

class FormField {
    constructor(name, modelValue, rules) {
        this.rulesValidating = ref(0);
        this.touched = false;
        this.errors = computed(() => this._errors.filter(isDefined));
        this.validating = computed(() => this.rulesValidating.value > 0);
        this.hasError = computed(() => this.errors.value.length > 0);
        this.name = name;
        this._errors = reactive(rules.map(() => null));
        if (isRef(modelValue) || isReactive(modelValue)) {
            this.modelValue = modelValue;
            this._initialModelValue = deepCopy(unref(modelValue));
        }
        else if (isObject(modelValue)) {
            this.modelValue = reactive(modelValue);
            this._initialModelValue = deepCopy(this.modelValue);
        }
        else {
            this.modelValue = ref(modelValue);
            this._initialModelValue = deepCopy(unref(modelValue));
        }
    }
    setError(ruleNumber, error) {
        this._errors[ruleNumber] = error;
    }
    reset(toDefaultValues) {
        this.touched = false;
        if (toDefaultValues) {
            if (isRef(this.modelValue)) {
                if (isArray(this.modelValue.value)) {
                    this.modelValue.value = deepCopy(this._initialModelValue);
                }
                else {
                    this.modelValue.value = this._initialModelValue;
                }
            }
            else {
                const copy = deepCopy(this._initialModelValue);
                Object.assign(this.modelValue, copy);
            }
        }
        Object.assign(this._errors, this._errors.map(() => null));
    }
}

class ValidationError extends Error {
    constructor() {
        super('One or more validation errors occurred.');
    }
}

const isSimpleRule = (rule) => typeof rule === 'function';
class Form {
    constructor() {
        this.simpleMap = new Map();
        this.keyedSetMap = new Map();
        this.reactiveFormFieldMap = shallowReactive(new Map());
        this.trySetKeyedSet = trySet(this.keyedSetMap);
        this.tryGetKeyedSet = tryGet(this.keyedSetMap);
        this.tryGetSimple = tryGet(this.simpleMap);
        this.formFields = ref(new Set());
        this.submitting = ref(false);
        this.errors = computed(() => {
            const errors = [];
            for (const formField of this.reactiveFormFieldMap.values()) {
                errors.push(...formField.errors.value);
            }
            return errors;
        });
    }
    registerField(uid, name, modelValue, rules) {
        const formField = new FormField(name, modelValue, rules);
        const simple = {
            formField,
            keys: [],
            vs: [],
            rollbacks: []
        };
        rules.forEach((rule, ruleNumber) => {
            const validate = Form.validateFactory(formField, rule, ruleNumber);
            if (isSimpleRule(rule)) {
                if (typeof validate !== 'undefined') {
                    simple.vs.push(validate);
                }
            }
            else {
                const { key } = rule;
                const keyed = {
                    formField,
                    v: validate
                };
                const rollback = () => {
                    this.tryGetKeyedSet({
                        success: keyedSet => {
                            keyedSet.delete(keyed);
                            if (keyedSet.size === 0) {
                                this.keyedSetMap.delete(key);
                            }
                        }
                    })(key);
                };
                simple.keys.push(key);
                simple.rollbacks.push(rollback);
                this.trySetKeyedSet({
                    failure: keyedSet => keyedSet.add(keyed)
                })(key, new Set([keyed]));
            }
        });
        this.simpleMap.set(uid, simple);
        this.reactiveFormFieldMap.set(uid, formField);
        this.formFields.value.add(formField);
        return formField;
    }
    validate(uid) {
        const simple = this.simpleMap.get(uid);
        if (simple && simple.formField.touched) {
            return Promise.allSettled([
                ...simple.vs.map(v => v([simple.formField.modelValue])),
                ...this.getPromisesForKeys(simple.keys)
            ]);
        }
    }
    async validateAll(names) {
        const settledResults = await Promise.allSettled(this.getPromisesForNames(names));
        for (const result of settledResults) {
            if (result.status === 'rejected') {
                throw new ValidationError();
            }
        }
    }
    onDelete(uid) {
        this.tryGetSimple({
            success: ({ rollbacks, formField }) => {
                this.formFields.value.delete(formField);
                rollbacks.forEach(r => r());
            }
        })(uid);
        this.simpleMap.delete(uid);
        this.reactiveFormFieldMap.delete(uid);
    }
    resetFields(toDefaultValues = true) {
        for (const { formField } of this.simpleMap.values()) {
            formField.reset(toDefaultValues);
        }
    }
    getPromisesForKeys(keys) {
        const promises = [];
        for (const key of keys) {
            this.tryGetKeyedSet({
                success: keyedSet => {
                    if (this.isEveryFormFieldTouchedWith(key)) {
                        const values = [...keyedSet.values()];
                        const modelValues = values.map(({ formField }) => formField.modelValue);
                        const vs = values
                            .map(({ v }) => v)
                            .filter(isDefined)
                            .map(v => v(modelValues));
                        promises.push(...vs);
                    }
                }
            })(key);
        }
        return promises;
    }
    getPromisesForNames(names) {
        const promises = [];
        if (typeof names === 'undefined') {
            for (const { formField, vs } of this.simpleMap.values()) {
                formField.touched = true;
                promises.push(...vs.map(v => v([formField.modelValue])));
            }
            promises.push(...this.getPromisesForKeys(this.keyedSetMap.keys()));
        }
        else if (names.length > 0) {
            const nameSet = new Set(names);
            for (const { formField, keys, vs } of this.simpleMap.values()) {
                if (nameSet.has(formField.name)) {
                    formField.touched = true;
                    promises.push(...vs.map(v => v([formField.modelValue])));
                    promises.push(...this.getPromisesForKeys(keys));
                }
            }
        }
        return promises;
    }
    isEveryFormFieldTouchedWith(key) {
        let everyFormFieldIsTouched = true;
        this.tryGetKeyedSet({
            success: keyedSet => {
                for (const { formField } of keyedSet) {
                    if (!formField.touched) {
                        everyFormFieldIsTouched = false;
                        break;
                    }
                }
            }
        })(key);
        return everyFormFieldIsTouched;
    }
    static validateFactory(formField, rule, ruleNumber) {
        const buffer = new LinkedList();
        const setError = (formField, ruleNumber, error) => {
            if (typeof error === 'string' && formField.touched) {
                formField.setError(ruleNumber, error);
                throw error;
            }
            else {
                formField.setError(ruleNumber, null);
            }
        };
        const validator = (formField, rule, ruleNumber) => async (modelValues) => {
            let error;
            const ruleResult = rule(...modelValues.map(unref));
            if (typeof (ruleResult === null || ruleResult === void 0 ? void 0 : ruleResult.then) === 'function') {
                formField.rulesValidating.value++;
                const node = buffer.addLast(false);
                if (node.prev) {
                    node.prev.value = true;
                }
                try {
                    error = await ruleResult;
                }
                catch (err) {
                    error = err;
                }
                buffer.remove(node);
                formField.rulesValidating.value--;
                if (!node.value) {
                    setError(formField, ruleNumber, error);
                }
            }
            else {
                error = ruleResult;
                setError(formField, ruleNumber, error);
            }
        };
        if (isSimpleRule(rule)) {
            return validator(formField, rule, ruleNumber);
        }
        else if (rule.rule) {
            return validator(formField, rule.rule, ruleNumber);
        }
    }
}

/**
 *
 * @param formData The structure of your Form Data.
 * @description
 * Vue composition function for Form Validation.
 * @docs
 * https://github.com/JensDll/vue3-form-validation
 * @typescript
 * For better type inference, consider defining the structure
 * of your `formData` upfront and pass it as the generic parameter `T`:
 * ```
 * type FormData = {
 *   name: Field<string>,
 *   email: Field<string>,
 *   password: Field<string>
 * }
 *
 * const { ... } = useValidation<FormData>({ ... })
 * ```
 */
function useValidation(formData) {
    const form = new Form();
    const promiseCancel = new PromiseCancel();
    transformFormData(form, formData);
    const transformedFormData = reactive(formData);
    return {
        form: transformedFormData,
        formFields: form.formFields,
        submitting: form.submitting,
        errors: form.errors,
        async validateFields(names) {
            form.submitting.value = true;
            const resultFormData = getResultFormData(transformedFormData);
            try {
                await promiseCancel.race(form.validateAll(names));
            }
            finally {
                form.submitting.value = false;
            }
            return resultFormData;
        },
        resetFields(formData) {
            if (form.submitting.value) {
                promiseCancel.cancelReject(new ValidationError());
            }
            if (formData) {
                form.resetFields(false);
                resetFields(formData, transformedFormData);
            }
            else {
                form.resetFields();
            }
        },
        add(path$1, value) {
            const lastKey = path$1[path$1.length - 1];
            if (typeof lastKey !== 'undefined') {
                const box = { [lastKey]: value };
                transformFormData(form, box);
                const x = path(path$1, transformedFormData);
                if (Array.isArray(x)) {
                    x.push(box[lastKey]);
                }
                else {
                    set(transformedFormData, path$1, box[lastKey]);
                }
            }
        },
        remove(path$1) {
            const lastKey = path$1.pop();
            if (typeof lastKey !== 'undefined' && path$1.length === 0) {
                cleanupForm(form, transformedFormData[lastKey]);
                delete transformedFormData[lastKey];
            }
            else if (typeof lastKey !== 'undefined') {
                const value = path(path$1, transformedFormData);
                if (Array.isArray(value)) {
                    const deleted = value.splice(+lastKey, 1);
                    cleanupForm(form, deleted);
                }
                else {
                    cleanupForm(form, value[lastKey]);
                    delete value[lastKey];
                }
            }
        }
    };
}

export { ValidationError, useValidation };

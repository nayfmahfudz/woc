import * as vue from 'vue';
import { ref, reactive, Ref, UnwrapRef, ComputedRef } from 'vue';

declare class FormField {
    private _errors;
    private _initialModelValue;
    name: string;
    rulesValidating: vue.Ref<number>;
    modelValue: ReturnType<typeof ref> | ReturnType<typeof reactive>;
    touched: boolean;
    errors: vue.ComputedRef<string[]>;
    validating: vue.ComputedRef<boolean>;
    hasError: vue.ComputedRef<boolean>;
    constructor(name: string, modelValue: any, rules: Rule[]);
    setError(ruleNumber: number, error: string | null): void;
    reset(toDefaultValues: boolean): void;
}

declare type RefUnrefObject<T extends Record<string, unknown>> = {
    [K in keyof T]: T[K] extends Ref ? T[K] | UnwrapRef<T[K]> : T[K] extends any[] ? Ref<T[K]> | T[K] : T[K] extends Record<string, unknown> ? RefUnref<T[K]> : Ref<T[K]> | T[K];
};
declare type RefUnref<T> = T extends Ref ? T | UnwrapRef<T> : T extends Record<string, unknown> ? RefUnrefObject<T> : Ref<T> | T;

declare type SimpleRule<T = any> = (value: T) => any;
declare type KeyedRule = {
    key: string;
    rule?: (...values: any[]) => any;
};
declare type Rule<T = any> = SimpleRule<T> | KeyedRule;
declare type Field<TValue> = {
    $value: RefUnref<TValue>;
    $rules?: Rule<TValue extends any[] ? TValue : UnwrapRef<TValue>>[];
};
declare type TransformedField<T> = {
    $uid: number;
    $value: T;
    $errors: string[];
    $hasError: boolean;
    $validating: boolean;
    $onBlur(): void;
};
declare type TransformedFormData<T extends object> = T extends any ? {
    [K in keyof T]: T[K] extends Field<infer TValue> | undefined ? T[K] extends undefined ? undefined : TransformedField<UnwrapRef<TValue>> : T[K] extends object ? TransformedFormData<T[K]> : T[K];
} : never;
declare type FormData<T extends object> = T extends any ? {
    [K in keyof T]: T[K] extends Field<infer TValue> | undefined ? UnwrapRef<TValue> : T[K] extends object ? FormData<T[K]> : T[K];
} : never;
declare type FieldNames<T> = T extends (infer TArray)[] ? FieldNames<TArray> : {
    [K in keyof T]-?: T[K] extends Field<any> | undefined ? K : FieldNames<T[K]>;
}[keyof T];
declare type Keys = readonly (string | number)[];
declare type DeepIndex<T, Ks extends Keys, R = unknown> = Ks extends [
    infer First,
    ...infer Rest
] ? First extends keyof T ? Rest extends Keys ? DeepIndex<T[First], Rest> : R : R : T;
declare type UseValidation<T extends object> = {
    form: TransformedFormData<T>;
    formFields: Ref<Set<FormField>>;
    submitting: Ref<boolean>;
    errors: ComputedRef<string[]>;
    validateFields(names?: FieldNames<T>[] | string[]): Promise<FormData<T>>;
    resetFields(formData?: Partial<FormData<T>>): void;
    add<Ks extends Keys>(path: readonly [...Ks], value: DeepIndex<T, Ks> extends Array<infer TArray> ? TArray : DeepIndex<T, Ks>): void;
    remove(path: (string | number)[]): void;
};
/**
 *
 * @param formData The structure of your Form Data.
 * @description
 * Vue composition function for Form Validation.
 * @docs
 * https://github.com/JensDll/vue3-form-validation
 * @typescript
 * For better type inference, consider defining the structure
 * of your `formData` upfront and pass it as the generic parameter `T`:
 * ```
 * type FormData = {
 *   name: Field<string>,
 *   email: Field<string>,
 *   password: Field<string>
 * }
 *
 * const { ... } = useValidation<FormData>({ ... })
 * ```
 */
declare function useValidation<T extends object>(formData: T): UseValidation<T>;

declare class ValidationError extends Error {
    constructor();
}

export { Field, ValidationError, useValidation };
